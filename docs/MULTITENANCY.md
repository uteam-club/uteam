# Руководство по мультитенантности в UTeam

## Что такое мультитенантность?

Мультитенантность (multitenancy) - это архитектурный подход, при котором одно приложение обслуживает несколько клиентов (тенантов), обеспечивая изоляцию их данных и конфигураций. В UTeam тенантами являются футбольные клубы.

## Реализация мультитенантности в UTeam

### 1. Идентификация тенанта

Идентификация тенанта в UTeam происходит двумя способами:

1. **По поддомену**: Каждый клуб имеет уникальный поддомен (например, `club1.uteam.app`).
2. **По clubId**: В базе данных и API-запросах клуб идентифицируется уникальным идентификатором.

### 2. Изоляция данных

В UTeam используется подход "разделенная база данных, общая схема":

- Все теннаты хранят данные в одной базе данных
- Каждая таблица содержит поле `clubId`, которое связывает записи с конкретным клубом
- Запросы к базе данных всегда включают фильтрацию по `clubId`

#### Пример запроса с фильтрацией:

```typescript
// Правильно - с фильтрацией по clubId
const teams = await db.select().from(team).where(eq(team.clubId, currentClubId));

// Неправильно - без фильтрации
const teams = await db.select().from(team); // Никогда не делайте так!
```

### 3. Маршрутизация и middleware

Middleware в Next.js анализирует поддомен и направляет запросы:

```typescript
// src/middleware.ts
export function middleware(request: NextRequest) {
  const host = request.headers.get('host') || '';
  const subdomain = getSubdomain(host);
  
  if (subdomain) {
    // Обработка запроса для конкретного клуба
    // ...
  }
}
```

### 4. Аутентификация и авторизация

Аутентификация пользователей включает проверку принадлежности к клубу:

1. При входе через поддомен проверяется, принадлежит ли пользователь к этому клубу
2. Токен JWT и сессия пользователя содержат `clubId`
3. Роли пользователей (`SUPER_ADMIN`, `ADMIN`, `COACH`, `MEMBER`) определяют права доступа

#### Пример проверки:

```typescript
// При входе через поддомен
if (subdomain) {
  const [club] = await db.select().from(club).where(eq(club.id, session.user.clubId));
  
  if (!club) {
    return NextResponse.json({ error: 'Club not found' }, { status: 404 });
  }
  
  if (user.clubId !== club.id) {
    return NextResponse.json({ error: 'Access denied' }, { status: 403 });
  }
}
```

## Хранение файлов и мультитенантность в Яндекс Облаке

UTeam использует Yandex Object Storage для хранения файлов (медиа, документов, аватаров и т.д.). Для обеспечения мультитенантности:

1. **Структура хранения**:
   - Все файлы каждого клуба хранятся в отдельной папке с именем clubId:
   ```
   bucket/
   ├── club1-uuid/
   │   ├── file1.jpg
   │   └── file2.pdf
   ├── club2-uuid/
   │   ├── file3.jpg
   │   └── file4.pdf
   ```
2. **Загрузка файлов**:
   - При загрузке файла путь всегда строится с учетом clubId:
   ```typescript
   const filePath = `${clubId}/${filename}`;
   await yandexStorage.upload('media', filePath, file);
   ```
3. **Доступ и безопасность**:
   - Доступ к файлам осуществляется только для пользователей, принадлежащих к соответствующему clubId.
   - Проверка clubId реализована на уровне приложения.

## Правила и рекомендации для поддержания мультитенантности

### Золотые правила

1. **Всегда фильтруйте по clubId**
   - Каждый запрос к базе данных должен включать фильтрацию по `clubId`
   - Никогда не возвращайте данные всех клубов на клиентскую сторону

2. **Проверяйте принадлежность**
   - Всегда проверяйте, имеет ли пользователь доступ к запрашиваемым данным
   - Проверяйте принадлежность пользователя к клубу при входе через поддомен

3. **Используйте контекст клуба**
   - Используйте `useClub()` для доступа к данным текущего клуба
   - Не храните данные клуба в глобальных переменных

4. **Разделяйте роли и права**
   - Супер-администраторы имеют доступ ко всем клубам
   - Администраторы клуба имеют полный доступ только к своему клубу
   - Члены клуба имеют ограниченный доступ к данным своего клуба

### Шаблоны для API-маршрутов

#### GET-запрос:

```typescript
export async function GET(request: NextRequest) {
  // Получение сессии и проверка авторизации
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  // Получение clubId
  const clubId = session.user.clubId;
  
  // Извлечение данных с фильтрацией по clubId
  const data = await db.select().from(entity).where(eq(entity.clubId, clubId));
  
  return NextResponse.json(data);
}
```

#### POST-запрос:

```typescript
export async function POST(request: NextRequest) {
  // Получение сессии и проверка авторизации
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  // Получение clubId
  const clubId = session.user.clubId;
  
  // Получение данных из запроса
  const data = await request.json();
  
  // Создание записи с привязкой к клубу
  await db.insert(entity).values({ ...data, clubId });
  
  return NextResponse.json(data);
}
```

### Особые случаи

#### 1. Супер-администратор

Супер-администраторы могут просматривать и управлять всеми клубами. Например:

```typescript
// Для супер-администраторов можно не ограничивать выборку по clubId
if (session.user.role === 'SUPER_ADMIN') {
  const allClubs = await db.select().from(club);
  return NextResponse.json(allClubs);
} else {
  // Для обычных пользователей - только свой клуб
  const [club] = await db.select().from(club).where(eq(club.id, session.user.clubId));
  return NextResponse.json([club]);
}
```

#### 2. Общие данные

Некоторые данные могут быть общими для всех клубов:

```typescript
// Данные, не связанные с конкретным клубом
const commonData = await db.select().from(commonEntity);
```

#### 3. Управление на уровне БД

Для дополнительной безопасности используется Row-Level Security в PostgreSQL:

```sql
-- Пример политики доступа на уровне БД
CREATE POLICY team_tenant_isolation 
  ON "Team" 
  USING (club_id = current_setting('app.current_club_id')::uuid);
```

## Тестирование мультитенантности

### Проверочный список

1. **Проверка функций на разных поддоменах**
   - Создайте тестовые поддомены (`club1.uteam.localhost`, `club2.uteam.localhost`)
   - Проверьте, что интерфейс и функциональность работают одинаково на всех поддоменах

2. **Проверка изоляции данных**
   - Создайте тестовые данные для разных клубов
   - Убедитесь, что пользователь клуба А не видит данные клуба Б
   - Проверьте, что супер-администратор видит данные всех клубов

3. **Проверка прав доступа**
   - Проверьте, что пользователи с разными ролями имеют ожидаемый доступ
   - Убедитесь, что административные функции недоступны обычным пользователям

### Автоматизированное тестирование

Для автоматизированного тестирования мультитенантности можно использовать следующий подход:

```typescript
// Пример теста для проверки изоляции данных
test('user can only see teams from their club', async () => {
  // Создание двух клубов
  const club1 = await createTestClub('club1');
  const club2 = await createTestClub('club2');
  
  // Создание пользователя в первом клубе
  const user1 = await createTestUser({ clubId: club1.id });
  
  // Создание команд в обоих клубах
  const team1 = await createTestTeam({ clubId: club1.id, name: 'Team A' });
  const team2 = await createTestTeam({ clubId: club2.id, name: 'Team B' });
  
  // Аутентификация как пользователь первого клуба
  const session = await loginAsUser(user1);
  
  // Запрос списка команд
  const response = await fetch('/api/teams', {
    headers: { Cookie: `session=${session}` }
  });
  
  const teams = await response.json();
  
  // Проверка, что видны только команды первого клуба
  expect(teams.length).toBe(1);
  expect(teams[0].id).toBe(team1.id);
  expect(teams.find(t => t.id === team2.id)).toBeUndefined();
});
```

## Улучшение производительности

Мультитенантная архитектура может влиять на производительность. Вот несколько рекомендаций:

1. **Индексация**
   - Добавьте индексы для полей `clubId` во всех таблицах:
     ```prisma
     @@index([clubId])
     ```

2. **Оптимизация запросов**
   - Используйте составные индексы для часто используемых запросов:
     ```prisma
     @@index([clubId, createdAt])
     ```

3. **Кэширование**
   - Кэшируйте данные с учетом принадлежности к клубу
   - Используйте составные ключи кэша с `clubId`

4. **Вертикальное масштабирование по тенантам**
   - При необходимости можно выделить крупных тенантов в отдельные базы данных

## Безопасность

### Потенциальные уязвимости

1. **Data Leakage (Утечка данных)**
   - Проблема: Отсутствие фильтрации по `clubId` может привести к утечке данных
   - Решение: Всегда включайте фильтрацию по `clubId` во все запросы

2. **Tenant Misconfiguration (Неправильная настройка тенанта)**
   - Проблема: Неправильная настройка может позволить доступ к другим тенантам
   - Решение: Автоматизированное тестирование безопасности

3. **Privilege Escalation (Повышение привилегий)**
   - Проблема: Пользователь может получить доступ к функциям администратора
   - Решение: Тщательная проверка ролей перед выполнением административных действий

### Лучшие практики безопасности

1. **Принцип наименьших привилегий**
   - Пользователи должны иметь только те права, которые необходимы для их работы

2. **Глубокая проверка прав**
   - Проверяйте права не только на уровне API, но и в бизнес-логике

3. **Аудит**
   - Ведите журнал важных действий с указанием `clubId`
   - Регулярно проверяйте журналы на подозрительную активность

4. **Защита от CSRF и XSS**
   - Используйте CSRF-токены для защиты от межсайтовой подделки запросов
   - Применяйте надлежащую санитизацию данных для предотвращения XSS-атак 